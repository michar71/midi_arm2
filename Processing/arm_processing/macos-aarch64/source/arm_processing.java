/* autogenerated by Processing revision 1293 on 2025-01-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.serial.*;
import java.lang.*;
import java.util.*;
import controlP5.*;
import com.jogamp.newt.opengl.GLWindow;
import ch.bildspur.artnet.*;
import java.util.*;
import themidibus.*;
import com.bckmnn.udp.*;
import java.net.InetSocketAddress;
import java.net.InetAddress;
import java.net.SocketAddress;
import java.util.*;
import java.math.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class arm_processing extends PApplet {

/*
This code is made for processing https://processing.org/

EVERYTHING SHOULD BE IN ORDER 
PITCH
ROLL
YAW
*/

     // import the Processing serial library






baboi_protocol bp;
baboi_midi bm;
baboi_artnet ba;
baboi_settings bs;
baboi_led_fx ledctrl;


ControlP5 cp5;

float p, r, y;

boolean isCal;
boolean isMap;
int lastUpdate = 0;

kalman KalFilterP;
kalman KalFilterR;
kalman KalFilterY;
kalman KalFilterT0;
kalman KalFilterT1;


int m1 = 0;
int m2 = 0;
int m3 = 0;
int m11 = 0;
int m22 = 0;
int m33 = 0;

PShape arrow;

boolean isLive = true;



public PVector getWindowLocation(String renderer) 
{
  PVector l = new PVector();
  if (renderer == P2D || renderer == P3D) 
  {
    com.jogamp.nativewindow.util.Point p = new com.jogamp.nativewindow.util.Point();
    ((com.jogamp.newt.opengl.GLWindow)surface.getNative()).getLocationOnScreen(p);
    l.x = p.getX();
    l.y = p.getY();
  } 
  else if (renderer == JAVA2D) 
  {
    java.awt.Frame f =  (java.awt.Frame) ((processing.awt.PSurfaceAWT.SmoothCanvas) surface.getNative()).getFrame();
    l.x = f.getX();
    l.y = f.getY();
  }
  return l;
}

public void Splitp(boolean theFlag) 
{
  bs.splitp = theFlag;
  bs.save_settings();
}

public void Splitr(boolean theFlag) 
{
  bs.splitr = theFlag;
  bs.save_settings();    
}

public void Splity(boolean theFlag) 
{
  bs.splity = theFlag;
  bs.save_settings();   
}

public void Artnet(boolean theFlag) 
{
  bs.artnet_en = theFlag;
  bs.save_settings();   

  if (bs.artnet_en == false)
  {
     ba.disable_artnet();
  }
  
}

public void Network(boolean theFlag) 
{
  bs.network_en = theFlag;
  bs.save_settings();    
}


public void settings()
{
  bs = new baboi_settings();
  bs.load_settings();
   
  if (bs.use2D)
    size(400, 260,P2D);
  else
    size(400, 260,P3D);
}


public void setup() {
   bp = new baboi_protocol(this,bs.uartOverride); 
   bm = new baboi_midi(bp,bs,bs.midiOut);
   ba = new baboi_artnet(bp,bs);
   ledctrl = new baboi_led_fx(16);

  
  surface.setTitle("BABOI CONTROL");
  surface.setResizable(false);
  
  frameRate(30);
  
  cp5 = new ControlP5(this);
  prepareExitHandler();
  

  //Create UI
  cp5.addButton("Range")
     .setBroadcast(false)
     .setValue(0)
     .setPosition(width-110,10)
     .setSize(100,18)
     .setBroadcast(true)
     ;
  
  cp5.addButton("Map")
     .setBroadcast(false)
     .setValue(100)
     .setPosition(width-110,30)
     .setSize(100,18)
     .setBroadcast(true)
     ;
  
    cp5.addToggle("Splitp")
     .setBroadcast(false)
     .setValue(bs.splitp)
     .setPosition(width-110,60)
     .setSize(18,18)
     .setLabel("Split P")
     .setBroadcast(true)
     ;
  
    cp5.addToggle("Splitr")
     .setBroadcast(false)
     .setValue(bs.splitr)
     .setPosition(width-70,60)
     .setSize(18,18)
     .setLabel("Split R")
     .setBroadcast(true)
     ;
     
    cp5.addToggle("Splity")
     .setBroadcast(false)
     .setValue(bs.splity)
     .setPosition(width-30,60)
     .setSize(18,18)
     .setLabel("Split Y")
     .setBroadcast(true)
     ;     
     
    cp5.addToggle("Artnet")
     .setBroadcast(false)
     .setValue(bs.artnet_en)
     .setPosition(width-44,height - 60)
     .setSize(18,18)
     .setLabel("ArtNet")
     .setBroadcast(true)
     ;   
     
    cp5.addToggle("Network")
     .setBroadcast(false)
     .setValue(bs.network_en)
     .setPosition(width-44,height - 30)
     .setSize(18,18)
     .setLabel("Network")
     .setBroadcast(true)
     ;      
     
     cp5.addButton("CalB")
     .setBroadcast(false)
     .setValue(0)
     .setPosition(5,height-20)
     .setSize(50,18)
     .setBroadcast(true)
     .setCaptionLabel("CAL B")
     ; 
     
     cp5.addButton("CalG")
     .setBroadcast(false)
     .setValue(0)
     .setPosition(60,height-20)
     .setSize(50,18)
     .setBroadcast(true)
     .setCaptionLabel("CAL G")
     ; 
     
     List<String> fxnames = new ArrayList<String>();
     ledctrl.getNames(fxnames);
     /* add a ScrollableList, by default it behaves like a DropdownList */
     cp5.addScrollableList("FXList")
       .setBroadcast(false)
       .setPosition(width-110,96)
       .setSize(100,120)
       .setBarHeight(20)
       .setItemHeight(20)
       .addItems(fxnames)
       .setValue(bs.fx)
       .setBroadcast(true)
       ;

  
  float p_noise = 4;//2
  float s_noise = 16;//32
  float e_error = 128;//128
 
  KalFilterP = new kalman(p_noise,s_noise,e_error,0.0f);
  KalFilterR = new kalman(p_noise,s_noise,e_error,0.0f);  
  KalFilterY = new kalman(p_noise,s_noise,e_error,0.0f);
  KalFilterT0 = new kalman(p_noise,s_noise,e_error,0.0f);  
  KalFilterT1 = new kalman(p_noise,s_noise,e_error,0.0f);  
  
  ledctrl.setNextFx(ledctrl.findByIndex(bs.fx));
  
  arrow = loadShape("arrow.obj");
  arrow.scale(100);
  float x = arrow.getChild(0).getVertex(0).x;
  float y = arrow.getChild(0).getVertex(0).y;
  float z = arrow.getChild(0).getVertex(0).z;
  
  arrow.translate(-x,-y,-z);
  //arrow.rotateX(PI);
  arrow.rotateY(PI);
}

public void FXList(int n)
{
  bs.fx = n; 
  ledctrl.setNextFx(ledctrl.findByIndex(bs.fx));
  bs.save_settings();
  
}


public void Range(int theValue) {
        if (isCal)
        {
          isCal = false;
          bs.save_settings();
        }
        else
        {
          isCal = true;
          bs.clear_cal_min_max();
        }
}



public void Map(int theValue) {
        if (isCal == false)
        isMap = !isMap;
}


public void CalG(int theValue)
{
  if (bp.checkConnected())
    bp.sendSetupRequest(1);
}

public void CalB(int theValue)
{
  if (bp.checkConnected())
    bp.sendSetupRequest(0);
}

public void show_map_text()
{
  fill(255);
  textAlign(LEFT);
  text("Mapping Keys:",130,height-80);
  text("Pitch=1,Roll=2,Yaw=3",130,height-64);
  text("P-Split=4,R-Split=5,=Y-Split=6",130,height-48);
  text("Button A=7,Button B=8",130,height-32);
  text("Finger 1=9,Finger 2=0",130,height-16);
}


public void show_acceleration()
{
  int r = (int)map(bp.accx,-4,4,64,255);
  int g = (int)map(bp.accy,-4,4,64,255);
  int b = (int)map(bp.accz+1,-4,4,64,255);
  stroke(r,g,b);
  fill(r,g,b);
}


public void draw_labels()
{

  hint(DISABLE_DEPTH_TEST);
  if (isCal)
  {
    fill(128,0,0);
    rect(0,0,160,66);
  }
  else if (isMap)
  {
    fill(0,128,0);
    rect(0,0,160,66);     
  }

  fill(255);
  
  textAlign(LEFT);
  textSize(14);
  text("P:"+nf(bp.cp,0,2),5,10);
  text("R:"+nf(bp.cr,0,2),5,22);
  text("Y:"+nf(bp.cy,0,2),5,34);
  text(nf(bs.minp,0,2)+"/"+nf(bs.maxp,0,2),60,10);
  text(nf(bs.minr,0,2)+"/"+nf(bs.maxr,0,2),60,22);
  text(nf(bs.miny,0,2)+"/"+nf(bs.maxy,0,2),60,34);
  
  if (bs.splitp)
    text(m1+"/"+m11,128,10);
  else
    text(m1,120,10);
    
  if (bs.splitr)  
    text(m2+"/"+m22,128,22);
  else
    text(m2,120,22);
  
  if (bs.splity)
    text(m3+"/"+m33,128,34);  
  else
    text(m3,120,34);  
      
      
  if (bp.b_A_state)
    text("A", 5,46);
  
  if (bp.b_B_state)
    text("B", 20,46);
    
  if (bp.b_C_state)
    text("C", 35,46);
    
  text(bp.deviceName+" V"+bp.maj_ver+"."+ bp.min_ver, 5,58);  

    
  if (isMap)
         show_map_text();
         
  
  hint(ENABLE_DEPTH_TEST);
}

public void delay(int time) {
  int current = millis();
  while (millis () < current+time) Thread.yield();
}


public void draw_cube()
{
  

  
  float dirY = (((float)height/4*3) / PApplet.parseFloat(height) - 0.5f) * 2;
  float dirX = (((float)width/4*3) / PApplet.parseFloat(width) - 0.5f) * 2;
  directionalLight(204, 204, 204, dirX, dirY, -1); //Why is this linked to the mouse? 
  //noStroke();
  pushMatrix();
  show_acceleration();
  translate(width/2, height/2);
  /*
  PMatrix3D rm = new PMatrix3D();
  rm = toMatrix(rm,qx,qy,qz,qw);
  applyMatrix(rm);
  */
  if (bp.tension_ch1 != -1)
  {
    translate(-180, 0, -100); 
    box(50, bp.tension_ch1, 50);
    translate(180, 0, 100); 
  }
  if (bp.tension_ch2 != -1)
  {
    translate(180, 0, -100); 
    box(50, bp.tension_ch2, 50);
    translate(-180, 0, 100);  
  }
  
  
  rotateY(y);//yaw
  rotateX(p);//pitch
  rotateZ(r);//roll

  shape(arrow);
  //TODO turen this into an arrow.....
  //box(100*1.5, 100/3, 100);
  
  
  popMatrix();
  
  
}


public void draw_horizon()
{
  text("T1:"+nf(bp.tension_ch1,0,2),5,70);
  text("T2:"+nf(bp.tension_ch2,0,2),5,82);
}



public void draw_led(int[] data)
{
  for(int yy=0;yy<data.length;yy++)
  {
    fill(data[yy]);
    stroke(data[yy]);
    rect(0,140-(yy*4),4,4);
  }
}

public void send_led()
{
  int[] ledData;
  
  //we map yaw, pitch, roll to 0..255
  int y = (int)map(bp.cy,bs.miny, bs.maxy, 0,255);
  y = (int)constrain(y,0,255);
  
  int r = (int)map(bp.cr,bs.minr, bs.maxr, 0,255);
  r = (int)constrain(r,0,255);
  
  int p = (int)map(bp.cp,bs.minp, bs.maxp, 0,255);  
  p = (int)constrain(p,0,255);
  
  ledctrl.setOrientation(y, p, r, bp.accx,bp.accy,bp.accz);
  ledctrl.setArtnet(ba.getArtnetData());
  ledData = ledctrl.updateLED();
  
  
  draw_led(ledData);
  bp.sendLEDdata(ledData);  
}

public void draw() 
{
  if(1==frameCount) 
  {
     surface.setLocation(bs.winx,bs.winy-28); //That '28' is the height of the menu bar... Ugly fudge but apparently hard to fix...
  }
  
  if (isLive)
    background(0);
  else
    background(255,0,0);
    
  if (bp.checkConnected())
  {
    if (bs.use2D)
    {
      draw_horizon();
    }
    else
    {
      draw_cube();
    }
    draw_labels();
  
    if (isCal)
    {
      calc_call_min_max();
    }
    else if (isMap)
    {
      //Do nothin...
    }
    else
    {
      if ((bp.checkConnected()) && (isLive))
      { 
        //Update midi and LED and Artnet 30 times/sec to limit data throughput
        if ((millis() - lastUpdate)>33)
        {
          lastUpdate = millis();
          bm.update_midi();
          if (bs.artnet_en)
          {
            ba.send_artnet();
            //Just a Test...
            send_led();
          }
        }
      }
    }
    
    //nake sure network is kept alive
    if (bp.checkConnected())
    {
      bp.send_ping();
      bp.check_timeout();  
    }
  }
  else
  {
    fill(255,0,0);
    stroke(255,0,0);
    line(0,0,width,height);
    line(width,0,0,height);

    int w = (int)textWidth("NO CONNECTION");
    fill(0,0,0);
    stroke(255,0,0);
    rect(width/2-(w/2)-4,height/2-13-50,w+8,20);
    fill(255,0,0);   
    stroke(255,0,0);
    text("NO CONNECTION",width/2-(w/2),height/2-50);
    bp.reconnect(bs.network_en);
  }

  PVector loc = getWindowLocation(P3D);
  bs.winx = (int)loc.x;
  bs.winy = (int)loc.y;
}


public void calc_call_min_max()
{
  if (bp.cp<bs.minp)
    bs.minp = bp.cp;
  if (bs.maxp<bp.cp)
    bs.maxp=bp.cp;
  if (bp.cr< bs.minr)
    bs.minr = bp.cr;
  if (bs.maxr<bp.cr)
    bs.maxr= bp.cr;
  if (bp.cy<bs.miny)
    bs.miny = bp.cy;
  if (bs.maxy<bp.cy)
    bs.maxy=bp.cy;
}


public void keyPressed() 
{
     if (bp.checkConnected())
   {
    if (key == 'm')
    {
      if (isCal == false)
        isMap = !isMap;
    }
    
    if (isMap)
    {
      //Send midid map key here
      bm.send_midi_map(key);
        
    }
    else
    {
      if (key == 'r')
      {
        if (isCal)
        {
          isCal = false;
          bs.save_settings();
        }
        else
        {
          isCal = true;
          bs.clear_cal_min_max();
        }
      }      
    }
   }
}
   
private void prepareExitHandler () 
{

Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() 
{
  public void run () 
  {
    System.out.println("SHUTDOWN HOOK");
    bs.save_settings();
  }
}));
}

public void serialEvent(Serial myPort) 
{  
  bp.serialEvent(myPort);
}

public void onUdpMessageRecieved(SocketAddress client, byte[] message)
{
  bp.onUdpMessageRecieved(client,message);
}


class baboi_artnet{
  
  ArtNetClient artnet;
  baboi_protocol bpr;
  baboi_settings bsr;  
  byte[] dmxData = new byte[512];
  
  public baboi_artnet(baboi_protocol bp,baboi_settings bs)
  {
    bpr = bp;
    bsr = bs;
    artnet = new ArtNetClient(null);
    artnet.start();
  }
  

  public void disable_artnet()
  {
    dmxData[0] = (byte) 0; 
    dmxData[1] = (byte) 0; 
    dmxData[2] = (byte) 0; 
    dmxData[3] = (byte) 0; 
    dmxData[4] = (byte) 0; 
    dmxData[5] = (byte) 0;     
    // send dmx to localhost
    //artnet.unicastDmx("127.0.0.1", 0, 0, dmxData);
    
    //Fuckit... Just send it to everybody ;-)
    artnet.broadcastDmx(0, 1, dmxData);
  }
  
  
  public void send_artnet()
{
    // fill dmx array
    int val = 0;

    val =(int)map(bpr.cr,bsr.minr, bsr.maxr, 0,255);
    val = (int)constrain(val,0,255);
    dmxData[0] = (byte) val;
    
    val =(int)map(bpr.cp,bsr.minp, bsr.maxp, 255,0);
    val = (int)constrain(val,0,255);
    dmxData[1] = (byte) val;
    
    val =(int)map(bpr.cy,bsr.miny, bsr.maxy, 0,255);
    val = (int)constrain(val,0,255);
    dmxData[2] = (byte) val;
    
    val = (int)map(abs(bpr.accx),0,6,0,255);    
    val = (int)constrain(val,0,255);
    dmxData[3] = (byte) val; 

    val = (int)map(abs(bpr.accy),0,6,0,255);    
    val = (int)constrain(val,0,255);
    dmxData[4] = (byte) val; 

    val = (int)map(abs(bpr.accz),0,6,0,255);
    val = (int)constrain(val,0,255);
    dmxData[5] = (byte) val; 

    //Send glove data if it exists
    if (bpr.tension_ch1 != -1)
    {
      dmxData[6] = (byte)bpr.tension_ch1;
    }
    else
    {
      dmxData[6] = (byte) 0; 
    }
    if (bpr.tension_ch2 != -1)
    {
      dmxData[7] = (byte)bpr.tension_ch2;
    }
    else
    {
      dmxData[7] = (byte) 0; 
    }

    // send dmx to localhost
    //artnet.unicastDmx("127.0.0.1", 0, 0, dmxData);
    
    //Fuckit... Jsut send it to everybody ;-)
    artnet.broadcastDmx(0, 1, dmxData);
    
    //send dmx to specific client
    //artnet.unicastDmx("192.168.0.133",0, 1, dmxData);
}

//Get artnet Data
public byte[]  getArtnetData()
{
  byte[] data;
  if (artnet != null)
  {
    try
    {
      data = artnet.readDmxData(0, 0);
    }
    catch (NullPointerException e)
    {
      return null;
    }
    
    return data;
  }
  else
  {
    return null;
  }
}

  
  
}
//Link To LED FX
// -maintiain list
// - Manage active FX
// = Distribute Parameters
// - Generate LED Data for Update


 

class baboi_led_fx{
  
    protected led_fx_base current_fx;
    protected led_fx_base next_fx;

  
    protected boolean newFx = false;
    protected int fxHeight;
    protected PGraphics fxGfx;
    public boolean useDecay = false;
  
  class fx_member
  {
      public String fx_name; 
      public led_fx_base fx;
      
      fx_member(led_fx_base fxs, String name)
      {
        fx_name = name;
        fx = fxs;
      }
  };

  public List<fx_member> fxlist = new ArrayList<fx_member>();
  int fxindex = 0;

  baboi_led_fx(int height)
  {
    fxHeight = height;
    
    //Add the Effects to a list
    fxlist.add(new fx_member((led_fx_base)new led_fx_none(fxHeight),"None"));
    fxlist.add(new fx_member((led_fx_base)new led_fx_test(fxHeight),"Test"));
    fxlist.add(new fx_member((led_fx_base)new led_fx_pry(fxHeight),"PRY"));
    fxlist.add(new fx_member((led_fx_base)new led_fx_cylon(fxHeight),"Cylon"));
    fxlist.add(new fx_member((led_fx_base)new led_fx_artnet(fxHeight),"ArtNet"));
  
    current_fx = getCurrent();
    next_fx = current_fx;
    newFx = false;
    fxGfx = createGraphics(1, fxHeight,P2D);
  }
  
  public void setNextFx(led_fx_base fx)
  {
    next_fx = fx;
    newFx = true;
  }
  
  public void SetDecayOn(boolean val)
  {
    useDecay = val;
  }
  
    public void setParam(String param, int value)
  {
    current_fx.setParam(param,value);
  }
  
  public int getParam(String param)
  {
    return current_fx.getParam(param);
  }
    
   public void setFilename(String filen)
  {
    current_fx.setFilename(filen);
  }
  
    public void saveData()
  {
    current_fx.saveData();
  }
  
public boolean hasNext()
{
  if ((fxindex+1) > fxlist.size()-1)
    return false;
  else 
    return true;
}

public boolean hasPrevious()
{
  if ((fxindex-1) < 0)
    return false;
  else 
    return true;
}

public led_fx_base getNext()
{
  if (hasNext())
  {
    fxindex++;
    return fxlist.get(fxindex).fx;
  }
  return null;
}

public led_fx_base getPrevious()
{
  if (hasPrevious())
  {
    fxindex--;
    return fxlist.get(fxindex).fx;
  }
  return null;
}

public String getFxName()
{
  return fxlist.get(fxindex).fx_name;
}

public boolean setIndex(int index)
{
  if((index > 0) & (index < fxlist.size()-1))
  {
    fxindex = index;
    return true;
  }
  else
  {
    return false;
  }
}

public int getIndex()
{
  return fxindex;
}

public led_fx_base getCurrent()
{
    return fxlist.get(fxindex).fx;
}

public led_fx_base findByName(String name)
{
  for (int jj=0;jj<fxlist.size();jj++)
  {
    if (fxlist.get(jj).fx_name.equals(name) == true)
      return fxlist.get(jj).fx;
  }
  return null;
}

public led_fx_base findByIndex(int ii)
{
  if (ii<fxlist.size())
  {
      return fxlist.get(ii).fx;
  }
  return null;
}

public void getNames(List fxnames)
{
  for (int ii=0;ii< fxlist.size();ii++)
  {
    fxnames.add(fxlist.get(ii).fx_name);
  }
}

public void setOrientation(float yaw, float pitch, float roll, float accX, float accY, float accZ)
{
  current_fx.setOrientation(yaw, pitch, roll, accX, accY, accZ);
}
      

public int[] updateLED()
{
  int[] ledData = new int[16];

  if (next_fx != current_fx)
  {
    current_fx = next_fx;
  }
  
  
  if (true == current_fx.update(System.nanoTime()/1000,useDecay,fxGfx))
  {
     //UPdate LEDs
     fxGfx.loadPixels();
     for (int yy=0;yy<fxHeight;yy++)
     {
       ledData[yy] = fxGfx.pixels[yy];
     }    
  }
  return ledData;
}


public void setArtnet(byte[] data)
{
  if (data != null)
    current_fx.setArtnet(data);
}


}
 //Import the library


class baboi_midi{


boolean last_A_state = false;
boolean last_B_state = false;
boolean last_C_state = false;

baboi_protocol bpr;
baboi_settings bsr;
MidiBus myBus; // The MidiBus

 public baboi_midi(baboi_protocol bp,baboi_settings bs,String bus)
{
    bpr = bp;
    bsr = bs;
    MidiBus.list();
    myBus = new MidiBus(this, -1, bus); // Create a new MidiBus with no input device and the default MacOS Midi Distributor as output
    //myBus = new MidiBus(this, -1, "Bluetooth"); // Midi Bus needs to be selectable or a command line/settings parameter
} 

  
  
  

public void send_midi()
{
  
  if (bsr.splitp)
  {
      float half = map(50,0,100, bsr.minp,bsr.maxp);
      if (bpr.cp < half)
      {
        m1 =(int)map(bpr.cp,bsr.minp, half, 127,0);
        m1 = (int)constrain(m1,0,127);
        m11 = 0;
      }
      else
      {
        m11 =(int)map(bpr.cp,half, bsr.maxp, 0,127);
        m11 = (int)constrain(m11,0,127);
        m1 = 0;
      }
      ControlChange change1 = new ControlChange(0, 1, m1);
      myBus.sendControllerChange(change1);
      ControlChange change2 = new ControlChange(0, 4, m11);
      myBus.sendControllerChange(change2);        
  }
  else
  {
    m11 = 0;
    m1 =(int)map(bpr.cp,bsr.minp, bsr.maxp, 0,127);
    m1 = (int)constrain(m1,0,127);
    ControlChange change1 = new ControlChange(0, 1, m1);
    myBus.sendControllerChange(change1);
  }
  
  if (bsr.splitr)
  {
      float half = map(50,0,100, bsr.minr,bsr.maxr);
      if (bpr.cr < half)
      {
        m2 =(int)map(bpr.cr,bsr.minr, half, 127,0);
        m2 = (int)constrain(m2,0,127);
        m22 = 0;
      }
      else
      {
        m22 =(int)map(bpr.cr,half, bsr.maxr, 0,127);
        m22 = (int)constrain(m22,0,127);
        m2 = 0;
      } 
      ControlChange change1 = new ControlChange(0, 2, m2);
      myBus.sendControllerChange(change1);
      ControlChange change2 = new ControlChange(0, 5, m22);
      myBus.sendControllerChange(change2);           
  }
  else
  {
    m22 = 0;
    m2 =(int)map(bpr.cr,bsr.minr, bsr.maxr, 0,127);
    m2 = (int)constrain(m2,0,127);
    ControlChange change1 = new ControlChange(0, 2, m2);
    myBus.sendControllerChange(change1);
  }
  
  if (bsr.splity)
  {
      float half = map(50,0,100, bsr.miny,bsr.maxy);
      if (bpr.cy < half)
      {
        m3 =(int)map(bpr.cy,bsr.miny, half, 127,0);
        m3 = (int)constrain(m3,0,127);
        m33 = 0;
      }
      else
      {
        m33 =(int)map(bpr.cy,half, bsr.maxy, 0,127);
        m33 = (int)constrain(m33,0,127);
        m3 = 0;
      }
      ControlChange change1 = new ControlChange(0, 3, m3);
      myBus.sendControllerChange(change1);
      ControlChange change2 = new ControlChange(0, 6, m33);
      myBus.sendControllerChange(change2);            
  }
  else
  {
    m33 = 0;
    m3 =(int)map(bpr.cy,bsr.miny, bsr.maxy, 0,127);
    m3 = (int)constrain(m3,0,127);
    ControlChange change1 = new ControlChange(0, 3, m3);
    myBus.sendControllerChange(change1);
  }
  
  //Send Tension midi data... We only send it if it actually exists (not -1...)
  if (bpr.tension_ch1 != -1)
  {
    ControlChange change = new ControlChange(0, 9, bpr.tension_ch1/2);
    myBus.sendControllerChange(change);
  }
  if (bpr.tension_ch2 != -1)
  {
    ControlChange change = new ControlChange(0, 10, bpr.tension_ch2/2);
    myBus.sendControllerChange(change);
  }
}


public void send_buttons()
{

  if ((last_A_state == false) && (bpr.b_A_state == true))
  {
    last_A_state = bpr.b_A_state;
    ControlChange change1 = new ControlChange(0, 7, 1);
    myBus.sendControllerChange(change1);
  }

  else if ((last_A_state == true) && (bpr.b_A_state == false))
  {
    last_A_state = bpr.b_A_state;
    ControlChange change1 = new ControlChange(0, 7, 0);
    myBus.sendControllerChange(change1);
  }

  if ((last_B_state == false) && (bpr.b_B_state == true))
  {
    last_B_state = bpr.b_B_state;
    ControlChange change1 = new ControlChange(0, 8, 1);
    myBus.sendControllerChange(change1);
  }

  else if ((last_B_state == true) && (bpr.b_B_state == false))
  {
    last_B_state = bpr.b_B_state;
    ControlChange change1 = new ControlChange(0, 8, 0);
    myBus.sendControllerChange(change1);
  }
  
  if ((last_C_state == false) && (bpr.b_C_state == true))
  {
    last_C_state = bpr.b_C_state;
    ControlChange change1 = new ControlChange(0, 9, 1);
    myBus.sendControllerChange(change1);
  }

  else if ((last_C_state == true) && (bpr.b_C_state == false))
  {
    last_C_state = bpr.b_C_state;
    ControlChange change1 = new ControlChange(0, 9, 0);
    myBus.sendControllerChange(change1);
  }  
}


public void send_midi_map(char mkey)
{
        
      if (mkey =='1')
      {
          ControlChange change1 = new ControlChange(0, 1, 63);
          myBus.sendControllerChange(change1);
      }
      if (mkey =='2')
      {
          ControlChange change1 = new ControlChange(0, 2, 63);
          myBus.sendControllerChange(change1);
      }
      if (mkey =='3')
      {
          ControlChange change1 = new ControlChange(0, 3, 63);
          myBus.sendControllerChange(change1);
      }   
      if (mkey =='4')
      {
          ControlChange change1 = new ControlChange(0, 4, 1);
          myBus.sendControllerChange(change1);
      }
      if (mkey =='5')
      {
          ControlChange change1 = new ControlChange(0, 5, 1);
          myBus.sendControllerChange(change1);
      }
      if (mkey =='6')
      {
          ControlChange change1 = new ControlChange(0, 6, 1);
          myBus.sendControllerChange(change1);
      }       
      if (mkey =='7')
      {
          ControlChange change1 = new ControlChange(0, 7, 1);
          myBus.sendControllerChange(change1);
      }
      if (mkey =='8')
      {
          ControlChange change1 = new ControlChange(0, 8, 1);
          myBus.sendControllerChange(change1);
      }
      if (mkey =='9')
      {
          ControlChange change1 = new ControlChange(0, 9, 1);
          myBus.sendControllerChange(change1);
      }   
      if (mkey =='0')
      {
          ControlChange change1 = new ControlChange(0, 10, 1);
          myBus.sendControllerChange(change1);
      }    
      if (mkey =='-')
      {
          ControlChange change1 = new ControlChange(0, 11 , 1);
          myBus.sendControllerChange(change1);
      } 
}

public void update_midi()
{
  send_midi();
  send_buttons();
}

}

//Really all the comm init and comm methods for the baboi should go in here...







class baboi_protocol{
//Data Sentences
char ID_DATA = 'D';   //Mition Data
char ID_QUERY = 'Q';  //Info Query
char ID_INFO = 'I';   //Answer to Query
char ID_SETUP = 'S';  //Setup Parameters (S:0 = Acc/Gyro Cal, S:1 = Glove Cal
char ID_PING = 'P';  //PING to reset timeout counter in uC 
char ID_LED = 'L';
  
//Put all parsed values here
float cp,cr,cy;
float accx,accy,accz;
int tension_ch1,tension_ch2;
boolean b_A_state = false;
boolean b_B_state = false;
boolean b_C_state = false;
String UARTOverride = "";

String ID = "";
int pos = 0;
int min_ver = 0;
int maj_ver = 0;
int HW_ver = 0;
String deviceName = "UNKNOWN";

int baboi_port = 2255;

UDPHelper udp;
SocketAddress lastUDPclient = null;
Serial myPort;                  // The serial port
String my_port = "/dev/cu.usbmodem145101";        // choose your port

boolean isConnected = false;
boolean isValidDevice=false;


int lastSerial = 0;
int lastPing = 0;
PApplet theSketch;


baboi_protocol(PApplet sketch,String UART)
{
  theSketch = sketch;
  UARTOverride = UART;
  udp = new UDPHelper(theSketch);
  udp.setLocalPort(baboi_port);
  udp.startListening();
}
  
public boolean checkConnected()
{
  return isConnected;
}

public boolean get_usbmodem_list(ArrayList<String> list)
{

  String substring = "usbmodem";
   
  try 
  {
    //printArray(Serial.list());
    int i = Serial.list().length;
    if (i != 0) 
    {
    //Build a list of all the USB Modems
      for (int j = 0; j < i;j++) 
      {
        if (Serial.list()[j].contains(substring) == true)
        {
          list.add(Serial.list()[j]);
        }
      }
      println(list);
      return true;
    }
    else
    {
      println("No Serial Port Found");
      return false;
    }
    
  }
  catch (Exception e)
  { //Print the type of error
    println("Serial List Error:", e);
    return false;  //Tried to connect but no success... Maybe already used?
  }
}


public boolean try_to_open(String comport)
{
  try
  {
    if (myPort !=null)
    {
      myPort.stop();
      myPort = null;
    }
    myPort = new Serial(theSketch, comport, 460800);
    if (myPort != null)
    {
      myPort.bufferUntil('\n');
      return true;
    }
    else 
    {
      return false; //No Serial Port device detected at all...
    }
  }
  catch (Exception e)
  { //Print the type of error
    println("Serial Open Error:", e);
    return false;  //Tried to connect but no success... Maybe already used?
  }  
}


public void reconnect(boolean nw)
{
      isConnected = try_connect_usb_modem();
    if (nw)
    {
      if (isConnected == false)
        isConnected = try_to_connect_wifi();
    }
}

public boolean ping_usbmodem()
{
  
  int maxping = 10;
  
   for(int ii=0;ii<maxping;ii++)
   {
     String id_query = bp.build_query();
     myPort.write(id_query);
     println("Query Sent "+ii);
     delay(200);

     //Need to be able to identify different types of BABOIs
     if (isValidDevice)
        return true;
   }
   return false;
}

public boolean try_connect_usb_modem()
{
  boolean hasList = false;
  boolean isOpen = false;

  ArrayList<String> Seriallist = new ArrayList<String>();
  //Build a list of all USB Modems
  hasList = get_usbmodem_list(Seriallist);
  if (hasList == false)
      return false;
      
  println("Available UARTs:");
  for (int ii = 0;ii < Seriallist.size();ii++)
    println(Seriallist.get(ii));


  if (0 == UARTOverride.compareTo(""))
  {
   println("Trying to Locate BABOI");
   //Loop Through List
   for (int ii = 0;ii < Seriallist.size();ii++)
   {
     isOpen = false;
     //Try to open Serial Port
     isOpen = try_to_open(Seriallist.get(ii));
     if (isOpen)
     {
       return ping_usbmodem();
     }
   }
  }
  else
  {
      println("?Using UART Override");
     isOpen = false;
     //Try to open Serial Port
     isOpen = try_to_open(UARTOverride);
     if (isOpen)
     {
       return ping_usbmodem();
     }    
  }
 
 return false;
}

public boolean try_to_connect_wifi()
{
  int maxping = 10;
 
  
  for(int ii=0;ii<maxping;ii++)
  {
    String id_query = bp.build_query();
    try
    {

      //SocketAddress all = new InetSocketAddress(InetAddress.getByName("192.168.1.1"),baboi_port);
      //udp.sendMessage(UDPHelper.bytesFromString(id_query),all);
        
      SocketAddress all = new InetSocketAddress(InetAddress.getByName("255.255.255.255"),baboi_port);
      udp.sendMessage(UDPHelper.bytesFromString(id_query),all);   
        
     } 
     catch(Exception e)
     {
       e.printStackTrace();
     }
     println("Wifi Query Sent "+ii);
     delay(200);

    //Need to be able to identify different types of BABOIs
    if (isValidDevice)
       return true;
   }
  return false;
}

public void send_ping()
{
  int pingRate = 1000;
  int current_time = millis();
  if ((current_time - lastPing) > pingRate)
  {
    lastPing = millis();
    sendPing();
  }
}

public void check_timeout()
{
  int timeout = 3000;
  int current_time = millis();
  if ((current_time - lastSerial) > timeout)
  {
    // Clear the buffer, or available() will still be > 0
    try
    {
      if (myPort != null)
      {
        myPort.clear();
        // Close the port
        myPort.stop();
      }
    }
    catch (Exception e)
    {
      println("Serial EXCEPTION");
    }
    println("TIMEOUT");
    isValidDevice = false;
    isConnected = false;
  }
}

public String build_query()
{
  return String.format("%c\n", ID_QUERY);
}
  
public void process_received_string(String myString)
{
  float v1,v2,v3,v4;
  
  myString = trim(myString);
  String[] list = split(myString, ':');
  //println(myString);
  
  if (list[0].contains(String.valueOf(ID_INFO)))
  {  
    deviceName = list[1];
    maj_ver = parseInt(list[2]);
    min_ver = parseInt(list[3]);
    //ID = list[4];
    HW_ver = parseInt(list[4]);
    pos = parseInt(list[5]);
    println(deviceName+":"+maj_ver+"."+min_ver+" ID:"+HW_ver+" POS:"+pos);
    isValidDevice = true;
    return;
  }
  else if (list[0].contains(String.valueOf(ID_DATA)))
  {
    float sensors[] = PApplet.parseFloat(list);
    v1 = sensors[9];
    if (v1 == 0)
    {
      isLive = false;
      b_A_state = false;
      b_B_state = false;
      b_C_state = false;
    }
    else
    {
      isLive = true;
      y = sensors[1];
      p = sensors[2];
      r = sensors[3];  
      
      p = KalFilterP.getFilteredRADValue(p);
      r = KalFilterR.getFilteredRADValue(r);     
      y = KalFilterY.getFilteredRADValue(y);
      
      cp = p;
      cy = y;
      cr = r;
      
      accx = sensors[4];
      accy = sensors[5];
      accz = sensors[6];   
      
      tension_ch1 = PApplet.parseInt(sensors[7]);   
      tension_ch2 = PApplet.parseInt(sensors[8]);  

      
      tension_ch1 = (int)KalFilterT0.getFilteredValue((float)tension_ch1);
      tension_ch2 = (int)KalFilterT1.getFilteredValue((float)tension_ch2);
      v2 = sensors[10];
      v3 = sensors[11];
      v4 = sensors[12];  
      
      
      if (v2 == 0)
        b_A_state = false;
      else
        b_A_state = true;
        
      if (v3 == 0)
        b_B_state = false;
      else
        b_B_state = true;
        
      if (v4 == 0)
        b_C_state = false;
      else
        b_C_state = true;         
    }
  }


  //println("roll: " + r + " pitch: " + p + " yaw: " + y + "\n"); //debug
  lastSerial = millis();
}


//HMMM.. .These should either go via Serial or Wifi... or both....
//check if network is activated
//Get a link to UDP helper on init
//Send messages accordingly
public void sendPing()
{
    String Ping = String.format("%c\n", ID_PING);
    myPort.write(Ping);
    
    if (lastUDPclient != null)
    {
      udp.sendMessage(UDPHelper.bytesFromString(Ping),lastUDPclient);   
    }
}

public void sendSetupRequest(int setupID)
{
    String Setup = String.format("%c:%d\n", ID_SETUP,setupID);
    myPort.write(Setup);
    
    if (lastUDPclient != null)
    {
      udp.sendMessage(UDPHelper.bytesFromString(Setup),lastUDPclient);   
    }
}

public void sendLEDdata(int[] data)
{
  StringBuilder stringBuilder = new StringBuilder();
  String ledData = "";
  
  if (data.length < 16)
    return;
    
  for (int ii=0; ii<16;ii++)
  {
    if (ii==15)
    {
      stringBuilder.append(str((int)((data[ii] >> 16) & 0xFF)));
      stringBuilder.append(",");
      stringBuilder.append(str((int)((data[ii] >>> 8 ) & 0xFF)));
      stringBuilder.append(",");
      stringBuilder.append(str((int)(data[ii] & 0xFF)));  
    }
    else
    {
      stringBuilder.append(str((int)((data[ii] >> 16) & 0xFF)));
      stringBuilder.append(",");
      stringBuilder.append(str((int)((data[ii] >>> 8 ) & 0xFF)));
      stringBuilder.append(",");
      stringBuilder.append(str((int)(data[ii] & 0xFF)));  
      stringBuilder.append(",");      
    }
  }
  ledData = stringBuilder.toString();
  String Led = String.format("%c:%s\n", ID_LED,ledData);
  myPort.write(Led);
  
  if (lastUDPclient != null)
  {
    udp.sendMessage(UDPHelper.bytesFromString(Led),lastUDPclient);   
  }
}


//This sould receive broadcast and unicast....
public void onUdpMessageRecieved(SocketAddress client, byte[] message)
{
  lastUDPclient = client;
  String messageString = UDPHelper.stringFromBytes(message);
  //println(client + " sent you this message: " + messageString);
  process_received_string(messageString);
}


public void serialEvent(Serial myPort) 
{  
  String myString = myPort.readStringUntil('\n'); 
  bp.process_received_string(myString);
}
}



class baboi_settings{
 
  
//Put all settings vartiables here\
float minp,maxp,minr,maxr,miny,maxy;
boolean splitp = false;
boolean splitr = false;
boolean splity = false;
boolean artnet_en =false;
boolean network_en =false;
String midiOut = "";
String uartOverride = "";
int winx;
int winy;
int fx;
boolean use2D = false;

 public void load_settings()
{
  JSONObject json;
  json = loadJSONObject("setup.json");
  
  if (json != null)
  {
    try
    {
      maxp = json.getFloat("maxp");
      minp = json.getFloat("minp");
      maxr = json.getFloat("maxr");
      minr = json.getFloat("minr");
      maxy = json.getFloat("maxy");
      miny = json.getFloat("miny");      

      splitp = json.getBoolean("splitp");
      splitr = json.getBoolean("splitr");
      splity = json.getBoolean("splity");
      
      artnet_en = json.getBoolean("artnet");
      network_en = json.getBoolean("network");
      
      winx = json.getInt("winx");        
      winy = json.getInt("winy");      
      fx = json.getInt("fx");  
    }
    
    catch (Exception e)
    { //Print the type of error
      println("Error loading Preset", e);
    }
    
    try
    {
      use2D = json.getBoolean("use2D");
      if (use2D)
        println("Force 2D Renderer");
      else
        println("Using 3D");
    }
    catch (Exception e)
    { //Print the type of error
      println("Using 3D");
    }
    
    
    try
    {
      midiOut = json.getString("midiBusOut","Bus 1");
      println("Using Midi Bus Out:" + midiOut);
    }
    catch (Exception e)
    { //Print the type of error
      midiOut = "Bus 1";
      println("Using Default Midi Bus Out:" + midiOut);
    }    
   
    try
    {
      uartOverride = json.getString("UARToverride","");
      if (0 == uartOverride.compareTo(""))
        println("Using default UART");
      else
        println("Using Custom UART:" + uartOverride);
    }
    catch (Exception e)
    { //Print the type of error
      uartOverride = "";
      println("Using Default UART");
    }          
  }
}

public void save_settings()
{
  JSONObject json = new JSONObject();

  json.setFloat("maxp",maxp);
  json.setFloat("minp",minp);
  json.setFloat("maxr",maxr);
  json.setFloat("minr",minr);
  json.setFloat("maxy",maxy);
  json.setFloat("miny",miny);
  
  json.setBoolean("splitp",splitp);    
  json.setBoolean("splitr",splitr);  
  json.setBoolean("splity",splity);  
  
  json.setBoolean("artnet",artnet_en);
  json.setBoolean("network",network_en);

  json.setInt("winx",winx);  
  json.setInt("winy",winy);  
  json.setInt("fx",fx);  
  
  saveJSONObject(json,"setup.json");
}

public void clear_cal_min_max()
{
  minp = 65535;
  maxp = -65535;
  minr = 65535;
  maxr = -65535;  
  miny = 65535;
  maxy = -65535; 
}



}
 



class kalman {
    /* Kalman filter variables */
    protected float q; //process noise covariance
    protected float r; //measurement noise covariance
    protected float x; //value
    protected float p; //estimation error covariance
    protected float k; //kalman gain
    protected float offset;
    protected float lastpos;

    kalman(float process_noise, float sensor_noise, float estimated_error, float intial_value) 
    {
      /* The variables are x for the filtered value, q for the process noise, 
         r for the sensor noise, p for the estimated error and k for the Kalman Gain. 
         The state of the filter is defined by the values of these variables.
         
         The initial values for p is not very important since it is adjusted
         during the process. It must be just high enough to narrow down.
         The initial value for the readout is also not very important, since
         it is updated during the process.
         But tweaking the values for the process noise and sensor noise
         is essential to get clear readouts.
         
         For large noise reduction, you can try to start from: (see http://interactive-matter.eu/blog/2009/12/18/filtering-sensor-data-with-a-kalman-filter/ )
         q = 0.125
         r = 32
         p = 1023 //"large enough to narrow down"
         e.g.
         myVar = Kalman(0.125,32,1023,0);
      */
        this.q = process_noise;
        this.r = sensor_noise;
        this.p = estimated_error;
        this.x = intial_value; //x will hold the iterated filtered value
        lastpos = intial_value;
    }
    
    public float getFilteredValue(float measurement) 
    {

    //Do Filtering
    this.p = this.p + this.q;
      
    //measurement update
    this.k = this.p / (this.p + this.r);
    this.x = this.x + this.k * (measurement - this.x);   
    this.p = (1 - this.k) * this.p;
    
    return this.x;
    }
    
    public void setParameters(float process_noise, float sensor_noise, float estimated_error) 
    {
        this.q = process_noise;
        this.r = sensor_noise;
        this.p = estimated_error;
    }  

    public void setParameters(float process_noise, float sensor_noise) 
    {
        this.q = process_noise;
        this.r = sensor_noise;
    }
    
    public float getProcessNoise() 
    {
      return this.q;
    }
    
    public float getSensorNoise() 
    {
      return this.r;
    }
    
    public float getEstimatedError() 
    {
      return this.p;
    }
    

    public float getFilteredRADValue(float measurement)
    {
      if ((lastpos < (-PI/2.0f)) && (measurement > (PI/2.0f)))
        offset = offset - (2.0f*PI);
        
      else if ((lastpos > (PI/2.0f)) && (measurement < (-PI/2.0f)))
        offset = offset + (2.0f*PI);  
 
      lastpos = measurement;
      float fake_value = measurement + offset;
      float filtered_value = getFilteredValue(fake_value);
      
      //while(filtered_value > PI)
      //  filtered_value = filtered_value - (2*PI);
        
      //while (filtered_value < -PI)
      //  filtered_value = filtered_value + (2*PI);
        
      return filtered_value;  
    }
    
}
class led_fx_artnet extends led_fx_base
{
    int ledCnt = 0;

    led_fx_artnet(int height)
    {
      super(height);
      name = "Artnet";
      loadData();
    }
  
  
    public boolean run_linear_ani(long us, PGraphics gfx)
    {
      for(int ii=0;ii<16;ii++)
      {
        int col = color(dmxData[ii*3+0],dmxData[ii*3+1],dmxData[ii*3+2]);      
        gfx.set(0,ii,col);
      }
      return true;
  }
}
//-Base class for LED Effects

/*
FX Linear Base Class.

Linear visula effects (LED Strip, Stack of DMX Lights

FX Should follow these rules:
- Draw in their own graphic context (PGraphic instantiated as P2D)
- Be scalable (Extract size from the PGraphic Content)
- Not delete PGraphic (So we can stack effects)
- All durations are in microseconds !!!
- Time-independant (Update might be called on a non-regular base with a timestamp...)
- Begin/EndDraw is handled in update function, no need to call them in ani-functions
- Use the Params Dictionary to implement parameters that can change before or during animation run
- Maximum brightness shall be observed

- Generic Parameters for control 
BRIGHT[0..255]
SPEED [0..1000]
SCALE [0..1000]
DIR [0..359]
BURST [0/1]
COMPLEX [0..1000]

COL_R [0..255]
COL_G [0..255]
COL_B [0..255]
*/



int beatcount = 0;
class led_fx_base{
  
  //Common Parameters. Use these as we are supporting blending on these when set
  protected float maxBrightness =255;
  protected float current_red;
  protected float current_green;
  protected float current_blue;
  protected float current_dir;
  protected float current_speed;
  protected float current_complexity;
  protected float current_scale;
  protected float current_x;
  protected float current_y;
  protected float current_pitch;
  protected float current_roll;
  protected float current_yaw;
  protected float current_acc_x;
  protected float current_acc_y;
  protected float current_acc_z;
  protected int current_burst;
  protected boolean loop;
  protected boolean decay;
  protected boolean lerp;
  
  //Other Variables
  protected Dictionary params = new Hashtable(); 
  
  protected int fxHeight;
  protected String name;
  protected String filenamestr = "";
  
  private float lerpspeed = 4;
  protected int cnt = 0;
  protected  byte[] dmxData = new byte[512];
  
  //Class Creator
  led_fx_base(int height)
  {
    fxHeight = height;
    name = "Linear Base";
    //Not much to do here....
    params.put("BRIGHT",maxBrightness);
  }
  
  
  //-------------------------------------------------------------
  //  These functions to  be overriden in custom animation class
  //-------------------------------------------------------------
  public boolean run_linear_ani(long us, PGraphics gfx)
  {
      
    //Test Code...Draw Ascending color dots...
    switch(beatcount)
    {
      default:
      case 0:
        gfx.stroke(255,255,255);
        break;
      case 1:
        gfx.stroke(255,0,0);
        break;
      case 2:
        gfx.stroke(0,255,0);
        break;
      case 3:
        gfx.stroke(0,0,255);
        break;          
    }
    
    beatcount++;
    if (beatcount == 4)
      beatcount = 0;
    
    gfx.line(0,cnt,0,cnt+4);
    
    cnt++;
    if (cnt > fxHeight)
      cnt = 0;

    return true;
  }
  
  
   //--------------------------
   //  End of override Section
   //--------------------------
   
   
   
   
    public void clear_ani(PGraphics gfx)
    {
      gfx.beginDraw();
      gfx.stroke(0);
      gfx.line(0,0,0,gfx.height);
      gfx.endDraw();
    }
    
    
    
    //Set the maximum brightness
    public final void setBrightness(int b)
    {
      if (b>255)
        b = 255;
      if (b<0)
        b = 0;
      maxBrightness = b;  
        
    }
    
/*
Lerp a value. Pass in the old value and reasign the value to itself.
Example current_green = lerpVal(current_green,(int)params.get("COL_R"));
*/
    public final float lerpVal(float currentval, float newval)
    {
      if (newval != currentval)
      {
        if (abs(currentval - newval) < 0.5f)
        {
          currentval = newval;
          return newval;
        }
        
        if (newval > currentval)
        {
          return currentval + lerpspeed;
        }
        else
        {
          return currentval - lerpspeed;
        }
      }
      else
      {
        return currentval;
      }   
    }
    
    public final float updateval(float currentval,String field,boolean direct)
    {
      float val;
      
      try
      {
        if (params.get(field) instanceof Integer)
        {
           val = (float)(int)params.get(field);
        }
        else if (params.get(field) instanceof Float)
        {
           val = (float)params.get(field);
        }
        else
        {
           val = 0;
        }
        
        if (direct)
          return val;
        else  
          return lerpVal(currentval,val);
      }
      catch (NullPointerException e)
      {
        return 0;
      }
    }

    public final void updatevalswithlerp()
    {
      maxBrightness = updateval(maxBrightness,"BRIGHT",false);
      current_speed = updateval(current_speed,"SPEED",false);
      current_scale = updateval(current_scale,"SCALE",false);
      current_complexity = updateval(current_complexity,"COMPLEX",false);
      current_dir = updateval(current_dir,"DIR",false);                      
      current_red = updateval(current_red,"COL_R",false);
      current_green = updateval(current_green,"COL_G",false);
      current_blue = updateval(current_blue,"COL_B",false);
      current_x = updateval(current_x,"POS_X",false);
      current_y = updateval(current_y,"POS_Y",false);
      //dumpData();
    }


    public final void updatevals()
    {
      maxBrightness = updateval(maxBrightness,"BRIGHT",true);
      current_speed = updateval(current_speed,"SPEED",true);
      current_scale = updateval(current_scale,"SCALE",true);
      current_complexity = updateval(current_complexity,"COMPLEX",true);
      current_dir = updateval(current_dir,"DIR",true);                      
      current_red = updateval(current_red,"COL_R",true);
      current_green = updateval(current_green,"COL_G",true);
      current_blue = updateval(current_blue,"COL_B",true);
      current_x = updateval(current_x,"POS_X",true);
      current_y = updateval(current_y,"POS_Y",true);
    }   
    
    
    
    public final boolean update(long currentTimeUS,boolean useDecay,PGraphics gfx)
    {
      //First check if we need to update or not
      boolean anires = false;
      
      
      updatevalswithlerp();
        
      //Update Graphics  

      gfx.beginDraw();
      //gfx.stroke(0);
      //gfx.line(0,0,0,gfx.height);
      anires = run_linear_ani(currentTimeUS,gfx);
      gfx.endDraw();
      
      current_burst = 0;
      params.put("BURST",current_burst);

      
      //If decay is enabled on every frame we do not update we lower the brightness by some amount and refresh...
      if (useDecay == true)
      {
        gfx.beginDraw();
        gfx.tint(0,64);
        gfx.image(gfx,0,0);
        gfx.endDraw();
        anires = true;
      }
      
      return anires;
    }
    
    

    public final boolean checkParam(String keyname)
    {
      if (params.get(keyname)== null)
        return false;
      else
        return true;
    }
    
    public final void setParam(String keyname,int value)
    {
      params.put(keyname,value);
    }
    
    public final int getParam(String keyname)
    {
      return (int)params.get(keyname);
    }  
    

    public final String getName()
    {
      return name;
    }

    
    public final boolean loadData()
    {
      //Generate filename
      JSONArray values;
      String filename = name + ".json";
      
      //Check if file exists
      File f = dataFile(filename);
      boolean exist = f.isFile();
      if (exist == false)
      {
          saveData();
          return false;
      }

      //Load data from file  
       values = loadJSONArray(filename);
      for (int i = 0; i < values.size(); i++) 
      {   
        JSONObject setting = values.getJSONObject(i); 
        String param = setting.getString("param");
        int val = setting.getInt("val");
        params.put(param,val);
      }
      updatevals();
      return true;
    }
    
    public final boolean saveData()
    {
      JSONArray values;
       //create filename
      String filename = name + ".json";
      filename = dataPath(filename);

      
      //Save Data to file (We iterate through the current property list)
      values = new JSONArray();
      int i = 0;
      
      for (Enumeration k = params.keys(); k.hasMoreElements();) 
      { 
          String param = (String)k.nextElement(); 
          int val;
          if (params.get(param) instanceof Integer)
          {
             val = (int)params.get(param);
          }
          else if (params.get(param) instanceof Float)
          {
             val = (int)(float)params.get(param);
          }
          else
          {
             val = 0;
          }
          
          JSONObject setting = new JSONObject();

          setting.setString("param", param);
          setting.setInt("val", val);
          values.setJSONObject(i, setting);
          i++;
      } 
      saveJSONArray(values, filename); 
      return true;
    }
    
    
    
    public final void dumpData()
    {
      for (Enumeration k = params.keys(); k.hasMoreElements();) 
      { 
          String param = (String)k.nextElement(); 
          int val;
          if (params.get(param) instanceof Integer)
          {
             val = (int)params.get(param);
          }
          else if (params.get(param) instanceof Float)
          {
             val = (int)(float)params.get(param);
          }
          else
          {
             val = 0;
          }
          
          JSONObject setting = new JSONObject();

          print(param);
          print(":");
          println(val);
      } 
    }
    
    public final void setFilename(String filen)
    {
        filenamestr = filen;
        println(filenamestr);
    }
    
    
    public void setOrientation(float yaw, float pitch, float roll, float accX, float accY, float accZ)
    {
        current_pitch = pitch;
        current_roll = roll;
        current_yaw = yaw;
        current_acc_x = accX;
        current_acc_y = accY;
        current_acc_z = accZ;
    }
    
    public void setArtnet(byte[] data)
    {
      dmxData = data;
    }
}
class led_fx_cylon extends led_fx_base
{
    int Cnt = 0;
    int current_led = 0;

    led_fx_cylon(int height)
    {
      super(height);
      name = "PRY";
      loadData();
    }
  
  
    public boolean run_linear_ani(long us, PGraphics gfx)
    {
      gfx.tint(0,(int)map(current_pitch,0,255,16,128));
      gfx.image(gfx,0,0);
      
      //Cnt--;
      //if (Cnt <= 0)
      {
        Cnt = (int)(current_yaw / 16);

       
        colorMode(HSB,255);
        int col = color(current_roll,255,128);
        colorMode(RGB,255);
        gfx.set(0,current_led,col);
        
        current_led++;
        if (current_led == 16)
          current_led = 0;
      }

      
      return true;
  }
}


class led_fx_none extends led_fx_base
{
    led_fx_none(int height)
    {
      super(height);
      name = "None";
      loadData();
    }
  
  
    public boolean run_linear_ani(long us, PGraphics gfx)
    {
      //Test Code...Draw Ascending color dots...
      gfx.stroke(0,0,0);
      gfx.line(0,0,0,16);
      return true;
  }
}
class led_fx_pry extends led_fx_base
{
    int ledCnt = 0;

    led_fx_pry(int height)
    {
      super(height);
      name = "PRY";
      loadData();
    }
  
  
    public boolean run_linear_ani(long us, PGraphics gfx)
    {
      //Test Code...Draw Ascending color dots...
      gfx.stroke(current_pitch,current_roll,current_yaw);
      gfx.line(0,0,0,16);
      return true;
  }
}


class led_fx_test extends led_fx_base
{
    int current_led = 0;

    led_fx_test(int height)
    {
      super(height);
      name = "Test";
      loadData();
    }
  
  
    public boolean run_linear_ani(long us, PGraphics gfx)
    {
      gfx.stroke(0,0,0);
      gfx.line(0,0,0,15);        
      gfx.stroke(128,192,255);
      gfx.line(0,0,0,current_led);  
      
      current_led++;
      if (current_led == 16)
        current_led = 0;
      
      return true;
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "arm_processing" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
